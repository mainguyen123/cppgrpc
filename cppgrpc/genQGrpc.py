# coding: utf-8

import sys, os
import proto3parser as proto

genServicePrefix = 'Q'
genServicePostfix = '%sService'
genRPCtypesPrefix = ''
genRPCtypesPostfix = '_RPCtypes'
genCallDataPrefix = ''
genCallDataPostfix = 'CallData'
genSignalPrefix = ''
genSignalPostfix = 'Response'
genSrvSignalPostfix = 'Request'
genFilePrefix = ''
genFilePostfix = '.qgrpc.%s'

def _genServiceName(service, config): return genServicePrefix + service + genServicePostfix % config.title()
def _genRPCtype(rpc): return genRPCtypesPrefix + rpc + genRPCtypesPostfix
def _genCallData(rpc): return genCallDataPrefix + rpc + genCallDataPostfix
def _genSignal(rpc, config='client'): return genSignalPrefix + rpc + genSignalPostfix if config == 'client' else genSignalPrefix + rpc + genSrvSignalPostfix
def _genFile(package, config, ext='.h'): return genFilePrefix + package + (genFilePostfix % config) + ext

def RPCkind(rpc):
    if not rpc.paramisstream and (not rpc.returnisstream): return 'RPC_KIND_UNARY_T'
    elif rpc.paramisstream and (not rpc.returnisstream): return 'RPC_KIND_CLIENTSTREAMING_T'
    elif not rpc.paramisstream and rpc.returnisstream: return 'RPC_KIND_SERVERSTREAMING_T'
    else: return 'RPC_KIND_BIDISTREAMING_T'
    
    
def generateAutoGenText(grpc_pb_h_file):
    s = """\
// Generated by the %s compiler.  DO NOT EDIT!
// source: %s.proto
""" % (os.path.basename(__file__), grpc_pb_h_file)
    return s



def generateDeclarations(package, services, messages, grpc_pb_h_file, config):
    s = """\
#pragma once

#include <QObject>
#include "%s.grpc.pb.h"
#include "QGrpc%s.h"
#include "QGrpc%sMonitor.h"

""" % (grpc_pb_h_file, config.title(), config.title(),)
    for sm in services + messages: s += """using %s::%s;\n""" % (package, sm)
    return s




def generateCliClassDef(package, service):
    return """
class %s: public QObject, public QGrpcCliBase::ConnectivityFeatures<%s>, public QGrpcCliBase::MonitorFeatures<%s>
{
    Q_OBJECT
""" % (_genServiceName(service, 'client'), service, _genServiceName(service, 'client'))


def generateSrvClassDef(package, service):
    return """
class %s: public QObject, public QGrpcSrvBase::QGrpcServerService
{
    Q_OBJECT
""" % (_genServiceName(service, 'server'))


def generateCliRestOfClass():
    return """
};
"""

def generateSrvRestOfClass():
    return """
};
"""



def generateCliRPCtypes(service, rpc_list):
    s = ''
    def _gentypes(_rpc):
        return """\
    using %s = QGrpcCliBase::RPCtypes< QGrpcCliBase::%s, %s, %s, %s >;
""" % (_genRPCtype(_rpc.rpcname), RPCkind(_rpc), _rpc.paramtype, _rpc.returntype, _genServiceName(service, 'client'))

    for rpc in rpc_list: s += _gentypes(rpc)
    return s
    
def generateSrvRPCtypes(service, rpc_list):
    s = """\
    %s::AsyncService service_;
"""  % service
    def _gentypes(_rpc):
        return """\
    using %s = QGrpcSrvBase::RPCtypes< QGrpcSrvBase::%s, %s, %s, %s, %s::AsyncService >;
""" % (_genRPCtype(_rpc.rpcname), RPCkind(_rpc), _rpc.paramtype, _rpc.returntype, _genServiceName(service, 'server'), service)

    for rpc in rpc_list: s += _gentypes(rpc)
    
    
    s += '\n'
    needAnotherCallData = """\
        needAnotherCallData< %s, %s >();
"""
    s += """\
    virtual void makeRequests() override
    {
%s
    }
""" % (''.join( [needAnotherCallData % (_genRPCtype(_rpc.rpcname), _genCallData(_rpc.rpcname),) for _rpc in rpc_list] ).rstrip() )
    return s 


def generateCliClassCtors(service):
    genservicename = _genServiceName(service, 'client')
    return """
public:
    explicit %s():
        QGrpcCliBase::MonitorFeatures<%s>(this, &%s::channelStateChanged)
    {}

    virtual ~%s(){}
""" % (genservicename, genservicename, genservicename, genservicename)


def generateSrvClassCtors(service):
    genservicename = _genServiceName(service, 'server')
    return """
public:
    explicit %s(): QGrpcSrvBase::QGrpcServerService(&service_){}
    virtual ~%s(){}
""" % (genservicename, genservicename,)


def generateCliCallData(service, rpc_list):
    s = """
public:
"""
    def _gencd(rpc):
        genCD = _genCallData(rpc.rpcname)
        genrpctype = _genRPCtype(rpc.rpcname)
        return """
    struct %s : public QGrpcCliBase::ClientCallData< %s, %s >
    {
        virtual ~%s() {}
        %s() : QGrpcCliBase::ClientCallData< %s, %s >( &%s::%s ) {}
    };
""" % (genCD, genrpctype, genCD, genCD, genCD, genrpctype, genCD, _genServiceName(service, 'client'), _genSignal(rpc.rpcname, 'client'))

    for rpc in rpc_list: s += _gencd(rpc)
    return s
    
    
def generateSrvCallData(service, rpc_list):
    s = """
public:
"""
    def _gencd(rpc):
        genCD = _genCallData(rpc.rpcname)
        genrpctype = _genRPCtype(rpc.rpcname)
        return """
    struct %s : public QGrpcSrvBase::ServerCallData< %s, %s >
    {
        virtual ~%s() {}
        %s() : QGrpcSrvBase::ServerCallData< %s, %s >( &%s::%s, &%s::AsyncService::Request%s ) {}
    };
""" % (genCD, genrpctype, genCD, genCD, genCD, genrpctype, genCD, _genServiceName(service, 'server'), _genSignal(rpc.rpcname, 'server'), service, rpc.rpcname)

    for rpc in rpc_list: s += _gencd(rpc)
    return s


def generateCliFuncs(rpc_list):
    s = """
public:
"""
    def _genFunc(rpc):
        rpckind = RPCkind(rpc)
        gentypes = _genRPCtype(rpc.rpcname)
        gencd = _genCallData(rpc.rpcname)
        name = rpc.rpcname
        commonpart = """\
        if(!connected()) return;
        %s* call = new %s;""" % (gencd, gencd)
        if rpckind == 'RPC_KIND_UNARY_T':
            return """
    void %s(const %s::RequestType& request)
    {
%s
        call->request = request;
        call->responder = stub_->Async%s(&call->context, request, &cq_);
        call->responder->Finish(&call->reply, &call->status, (void*)call);
    }
""" % (name, gentypes, commonpart, name)
        elif rpckind == 'RPC_KIND_SERVERSTREAMING_T':
            return """
    void %s(const %s::RequestType& request)
    {
%s
        call->request = request;
        call->responder = stub_->Async%s(&call->context, request, &cq_, (void*)call);
    }
""" % (name, gentypes, commonpart, name)
        elif rpckind == 'RPC_KIND_CLIENTSTREAMING_T':
            return """
    void %s()
    {
%s
        call->responder = stub_->Async%s(&call->context, &call->reply, &cq_, (void*)call);
    }
""" % (name, commonpart, name)
        elif rpckind == 'RPC_KIND_BIDISTREAMING_T':
            return """
    void %s()
    {
%s
        call->responder = stub_->Async%s(&call->context, &cq_, (void*)call);
    }
""" % (name, commonpart, name)
        assert(False)
    
    for rpc in rpc_list: s += _genFunc(rpc)
    return s


def generateCliSignals(service, rpc_list):
    s = """

signals:
    void channelStateChanged(int /*prev*/, int /*cur*/);
"""
    def _genSig(rpc):
        return """
    void %s(%s::%s* /*response*/);
""" % (_genSignal(rpc.rpcname, 'client'), _genServiceName(service, 'client'), _genCallData(rpc.rpcname))

    for rpc in rpc_list: s += _genSig(rpc)
    return s
    
    
def generateSrvSignals(service, rpc_list):
    s = """

signals:
"""
    def _genSig(rpc):
        return """
    void %s(%s::%s* /*response*/);
""" % (_genSignal(rpc.rpcname, 'server'), _genServiceName(service, 'server'), _genCallData(rpc.rpcname))

    for rpc in rpc_list: s += _genSig(rpc)
    return s



def generateQGrpc(protofile, mode, outpath):
    #if mode == 'server': sys.exit('server mode not implemented yet')
    tpl = proto.parseProtoFile(protofile)
    if not tpl: sys.exit('Cannot parse proto file: %s' % protofile)
    outfname = os.path.splitext(os.path.basename(os.path.basename(protofile)))[0]
    package, services, messages = tpl
    res = generateAutoGenText(outfname)
    res += generateDeclarations(package, [s.name for s in services], messages, outfname, mode)
    for s in services:
        name = s.name
        if mode == 'client':
            res += ( generateCliClassDef(package, name) +
                 generateCliRPCtypes(name, s.rpc_list) +
                 generateCliClassCtors(name) +
                 generateCliCallData(name, s.rpc_list) +
                 generateCliFuncs(s.rpc_list) +
                 generateCliSignals(name, s.rpc_list) +
                 generateCliRestOfClass()
            )
        elif mode == 'server':
            res += ( generateSrvClassDef(package, name) +
                 generateSrvRPCtypes(name, s.rpc_list) +
                 generateSrvClassCtors(name) +
                 generateSrvCallData(name, s.rpc_list) +
                 generateSrvSignals(name, s.rpc_list) +
                 generateSrvRestOfClass()
            )
        res += '\n\n'
    outfile = os.path.join(outpath, _genFile(outfname, mode))
    try:
        with open(outfile, 'w') as f: f.write(res)
    except Exception as e: sys.exit(e)
    return


def main():
    help = 'usage: genQGrpc.py PROTOFILE {client,server} {OUTPATH,--get-outfile}'
    if len(sys.argv) != 4: sys.exit(help)
    protofile = os.path.abspath(sys.argv[1])
    mode = sys.argv[2]
    outpath = sys.argv[3]    
    if outpath == '--get-outfile':
        outfname = os.path.splitext(os.path.basename(os.path.basename(protofile)))[0]
        print(_genFile(outfname, mode, ext=''))
        return
    if not os.path.isfile(protofile): sys.exit('No such file: %s' % protofile)
    if not mode in ('client', 'server'): sys.exit('Bad mode: %s' % mode)
    if not os.path.isdir(outpath): sys.exit('No such path: %s' % outpath)
    generateQGrpc(protofile, mode, outpath)




if __name__ == '__main__':
    main()
